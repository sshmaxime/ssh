/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { FC, forwardRef, Ref, useEffect, useRef } from "react";
import { GLTF } from "three-stdlib";
import { Center, useGLTF } from "@react-three/drei";
import { loadIdTexture, loadTextureToObject } from "../utils/loaderTexture";
import React from "react";

type GLTFResult = GLTF & {
  nodes: {
    Tube: THREE.Mesh;
    Tube2_4: THREE.Mesh;
    Tube2_5: THREE.Mesh;
    Tube_1: THREE.Mesh;
    Tube2_1_1: THREE.Mesh;
    Tube2_1_2: THREE.Mesh;
    Tube_2: THREE.Mesh;
    Tube2_2_1: THREE.Mesh;
    Tube2_2_2: THREE.Mesh;
    Tube_3: THREE.Mesh;
    Tube2_3_1: THREE.Mesh;
    Tube2_3_2: THREE.Mesh;
    Absorber1: THREE.Mesh;
    Trucks: THREE.Mesh;
    Deck: THREE.Mesh;
    Placeholder: THREE.Mesh;
  };
  materials: {
    Wheels: THREE.MeshStandardMaterial;
    Trucks: THREE.MeshStandardMaterial;
    Deck: THREE.MeshStandardMaterial;
    Placeholder: THREE.MeshStandardMaterial;
  };
};

const modelPath = "/models/skate/skate-transformed.glb";

const defaultId = 0;

const texturePath = "/models/skate/textures/";

const defaultDeckTexture = texturePath + "deck0.png";
const defaultPlaceholderTexture = texturePath + "placeholder.png";

export type SkateRefs = ReturnType<typeof useSkateRefsLoader>;
export const useSkateRefsLoader = () => {
  return {
    groupRef: React.useRef<JSX.IntrinsicElements["group"]>(null),
    deckRef: React.useRef<JSX.IntrinsicElements["mesh"]>(null),
    placeholderRef: React.useRef<JSX.IntrinsicElements["mesh"]>(null),
    idRef: React.useRef<JSX.IntrinsicElements["meshBasicMaterial"]>(null),
  };
};

export const defaultSkateModelAnimation = (refs: SkateRefs) => ({
  changeTextureDeck(img: any) {
    loadTextureToObject(img, refs.deckRef);
  },
  changeTexturePlaceholder(img: any) {
    loadTextureToObject(img, refs.placeholderRef);
  },
  changeId(newId: number) {
    loadIdTexture(newId, refs.idRef);
  },
  changeVersion(newVersion: number) {
    this.changeTextureDeck(texturePath + "deck" + newVersion + ".png");
  },
});

export type ModelInitialProps = {
  initialId?: number;
  deckInitialTexture?: string;
  placeholderInitialTexture?: string;
};

export type ModelProps = ModelInitialProps & { refs: SkateRefs };

const Skate: FC<ModelProps & JSX.IntrinsicElements["group"]> = React.memo((props) => {
  const group = props.refs.groupRef;

  // setup refs
  const deckRef = props.refs.deckRef;
  const placeholderRef = props.refs.placeholderRef;
  const idRef = props.refs.idRef;

  // model
  const { nodes, materials } = useGLTF(modelPath) as GLTFResult;

  // Deck
  materials.Deck.color = null as any;
  materials.Deck.toneMapped = false;

  // // Placeholder
  materials.Placeholder.color = null as any;
  materials.Placeholder.toneMapped = false;

  // itemId
  const itemId = "#" + (props.initialId || defaultId);

  const canvas = document.createElement("canvas");

  const ctx = canvas.getContext("2d") as any;
  ctx.canvas.width = 500;
  ctx.canvas.height = 500;
  ctx.fillStyle = "rgba(0, 0, 0, 0)";
  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  ctx.textAlign = "center";
  ctx.font = "700 50px montserrat";
  ctx.fillStyle = "black";
  ctx.fillText(itemId, ctx.canvas.width / 2, ctx.canvas.height / 2);

  const newMaterial = new THREE.CanvasTexture(canvas);

  loadTextureToObject(props.deckInitialTexture || defaultDeckTexture, deckRef);
  loadTextureToObject(props.placeholderInitialTexture || defaultPlaceholderTexture, placeholderRef);

  return (
    <group ref={group} {...props}>
      <Center alignTop>
        <group rotation={[Math.PI, -Math.PI / 2, Math.PI / 2]} dispose={null}>
          <mesh
            ref={deckRef}
            geometry={nodes.Deck.geometry}
            material={materials.Deck}
            rotation={[Math.PI / 2, 0, 0]}
          />
          <mesh
            ref={placeholderRef}
            geometry={nodes.Placeholder.geometry}
            material={materials.Placeholder}
            rotation={[Math.PI / 2, 0, 0]}
          />
          <mesh position={[10, 6.7, 0]} rotation={[Math.PI / 2, 0, -Math.PI / -2]}>
            <planeGeometry args={[10, 10, 10, 10]} />
            <meshBasicMaterial ref={idRef} transparent map={newMaterial} />
          </mesh>
        </group>
      </Center>
    </group>
  );
});

useGLTF.preload(modelPath);

export default Skate;
